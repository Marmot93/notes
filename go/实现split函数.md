# [ä¸€èµ·è¯»æºç ] å…³äºsplitçš„è®¾è®¡

æ—¢ç„¶è¿™ä¸ªä¸“é¢˜æ˜¯å› ä¸º`split`å¼€å§‹çš„ï¼Œé‚£å°±ä¹Ÿä»`split`å¼€å§‹å§

## strings.Split

æŸ¥çœ‹æºç æˆ‘ä»¬å¯ä»¥å‘ç° `strings.Split` å’Œ `strings.SplitN` éƒ½æ˜¯å¥—å£³çš„ `strings.genSplit` è¿™é‡Œå°±ç›´æ¥å…³æ³¨ `strings.genSplit`äº†

## strings.genSplit
```go
// sï¼šå¾…åˆ†å‰²å­—ç¬¦ä¸²
// sepï¼šå­ä¸²ï¼Œ
// sepSaveï¼šåœ¨å­æ•°ç»„ä¸­åŒ…å«sepSaveå­—èŠ‚ï¼Œ 
// nï¼šæ‹†åˆ†å®Œæˆå­æ•°ç»„çš„æœ€å¤§é•¿åº¦
// å…³äº n çš„åˆ†å‰²åœ¨ SplitN çš„æ³¨é‡Šä¸­æœ‰è¯´æ˜ï¼š
//  n > 0: æœ€å¤š n ä¸ªå­ä¸²ï¼› æœ€åä¸€ä¸ªå­ä¸²å°†æ˜¯æœªæ‹†åˆ†çš„ä½™æ•°ã€‚
//  n == 0ï¼šç»“æœä¸ºé›¶ï¼ˆé›¶å­ä¸²ï¼‰
//  n < 0ï¼šæ‰€æœ‰å­ä¸²
func genSplit(s, sep string, sepSave, n int) []string {
    // n == 0ï¼šç»“æœä¸ºé›¶ï¼ˆé›¶å­ä¸²ï¼‰
	if n == 0 {
		return nil
    }
    // å½“ sep == "" çš„æ—¶å€™ï¼Œç›´æ¥ä½¿ç”¨ explode
    // explode å°† s æ‹†åˆ†ä¸ºä¸€æ®µ UTF-8 å­—ç¬¦ä¸²ï¼Œ
    // æ¯ä¸ª Unicode å­—ç¬¦ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæœ€å¤šä¸º nï¼ˆn < 0 è¡¨ç¤ºæ²¡æœ‰é™åˆ¶ï¼‰ã€‚
	if sep == "" {
		return explode(s, n)
    }
    // n < 0ï¼šæ‰€æœ‰å­ä¸²ï¼Œè¿™é‡Œä½¿ç”¨äº† strings.Count æ¥è®¡ç®—çœŸå®çš„nå€¼ï¼Œä»¥åŠéœ€è¦å‡†å¤‡å¤šå¤§çš„cap
    // åœ¨ä¸‹é¢æˆ‘ä»¬å†è§£æ strings.Count
    // string.Countçš„ä¸»ä½“å’Œä¸‹é¢çš„forå¾ªç¯åŠå…¶ç›¸ä¼¼ï¼Œå…¶æ ¸å¿ƒæ˜¯ strings.Index
	if n < 0 {
		n = Count(s, sep) + 1
    }
    // ç”¨æ¥å­˜ç»“æœçš„æ•°ç»„
    a := make([]string, n)
    // å› ä¸º n==0 å’Œ n<0 çš„æƒ…å†µï¼Œåœ¨ä¸Šé¢å·²ç»å…¨éƒ¨å¤„ç†æ‰äº†
    // æ‰€ä»¥è¿™é‡Œç›´æ¥ n-- äº†ï¼Œå‡å°‘ä¸€ä¸ªèµ‹å€¼
    // ä»è¿™é‡Œå¾€ä¸‹çš„ n å°±ä»£è¡¨éœ€è¦åˆ‡å‡ åˆ€äº†
	n--
	i := 0
	for i < n {
        // è¿™é‡Œè¿˜æ˜¯è°ƒç”¨çš„ strings.Index 
        // è¿”å›å€¼ m ä»£è¡¨ç¬¬ä¸€ä¸ªå¤åˆæ¡ä»¶çš„å­ä¸²çš„ç´¢å¼•
        m := Index(s, sep)
		if m < 0 {
            // m < 0 (å…¶å®å°±æ˜¯ -1) ä»£è¡¨æ²¡æ‰¾åˆ°ç¬¦åˆè°ƒèŠ‚çš„ï¼Œç›´æ¥è·³å‡ºå¾ªç¯
            // è¿™é‡Œçš„ç»“æœå…¶å®å°±æ˜¯ a[0] = s
			break
        }
        // æˆªå–åˆ‡å‰²å‡ºæ¥çš„å­ä¸²åŠ ä¸ŠsepSaveå­—èŠ‚ï¼Œæ”¾å…¥ a 
        a[i] = s[:m+sepSave]
        // åˆ‡å‰² s è¿›å…¥ä¸‹ä¸€ä¸ªå¾ªç¯
		s = s[m+len(sep):]
		i++
    }
    // å‰©ä½™å­—ç¬¦ä¸²çš„å…¨æ”¾è¿›å»
    a[i] = s
    // è¿™é‡Œåªå‰©ä¸‹ä¸€ä¸ªé—®é¢˜äº†ï¼Œä¸ºä»€ä¹ˆè¿”å›çš„æ˜¯ a[:i+1]ï¼Œè¿”å› i ä¸ªï¼Œæ²¡æœ‰ç”¨ nï¼Ÿ
    // å› ä¸º næ˜¯æ‹†åˆ†å®Œæˆå­æ•°ç»„çš„æœ€å¤§é•¿åº¦, n > iï¼Œæœ‰å¯èƒ½åˆ‡ä¸å‡ºæ¥ n ä¸ª
	return a[:i+1]
}
```
æ€»ç»“:ä¼˜ç§€çš„è¾¹ç•Œæ¡ä»¶å¤„ç†ï¼Œå°½å¯èƒ½å°‘çš„å†…å­˜ä½¿ç”¨ï¼Œæ­ªç‘ä¼˜ç§€çš„æºç ï¼ˆæˆ‘ä¼¼ä¹åœ¨è¯´åºŸè¯ï¼‰

## strings.Count
```go
// Count counts the number of non-overlapping instances of substr in s.
// If substr is an empty string, Count returns 1 + the number of Unicode code points in s.
func Count(s, substr string) int {
    // special case
    // åœ¨æ³¨é‡Šä¸­æœ‰è¯´æ˜ï¼šå½“ substr ä¸ºç©ºå­—ç¬¦ä¸²çš„æ—¶å€™ï¼Œè¿”å› 1 + Unicodeå­—èŠ‚æ•°
	if len(substr) == 0 {
        // TODO: è¿™é‡Œå…¶å®æœ‰ç‰µæ¶‰ len å’Œ utf8.RuneCountInString çš„åŒºåˆ«ï¼Œç•™å‘
        // è‡³äºè¿™é‡Œä¸ºä»€ä¹ˆè¦ utf8.RuneCountInString(s) + 1
        // åœ¨ https://pkg.go.dev/strings#Count çš„ Exampleä¸­æœ‰å†™æ˜ä¸º before & after each rune
        // å¦‚æœæœ‰å…¶ä»–æƒ³æ³•çš„æ¬¢è¿ç•™è¨€äº¤æµ
		return utf8.RuneCountInString(s) + 1
    }
    // substr æ˜¯å•ä¸ªå­—ç¬¦çš„æ—¶å€™ç”¨ bytealg.CountString 
    // bytealg.CountString è¿™ä¸ªæ˜¯è°ƒç”¨çš„æ±‡ç¼–äº†
    // åœ¨æºç çš„åŒç›®å½•ï¼Œä¸åŒå¹³å°çš„.sæ–‡ä»¶ä¸­æœ‰å¯¹åº”cpuæ¶æ„çš„çš„æ±‡ç¼–
    // æ±‡ç¼–è¿™ä¸ªå‘å¤ªå¤§ï¼Œæˆ‘è¿™é‡Œå®åœ¨å¡«ä¸åŠ¨äº†ï¼Œæœ‰å…´è¶£çš„å¯ä»¥äº†è§£ä¸€ä¸‹ğŸ˜‚
	if len(substr) == 1 {
		return bytealg.CountString(s, substr[0])
	}
	n := 0
	for {
        // TODOï¼šè¿™é‡Œåœ¨ä¸Šé¢æè¿‡ï¼Œä½¿ç”¨äº† strings.Index 
        // strings.Index çš„é™¤äº†è¾¹ç•Œå¤„ç†ä»¥å¤–
        // ä¸»è¦æ˜¯æ ¹æ®å¯„å­˜å™¨çš„æƒ…å†µæƒ…å†µä½¿ç”¨æš´åŠ›æ±‚è§£æˆ–è€…Rabin-Karpç®—æ³•
        // æŒ–ä¸ªå¤§å‘ï¼Œå¾…å¡«
        i := Index(s, substr)
        // æ²¡æ‰¾åˆ°è¿”å›è®¡æ•°
		if i == -1 {
			return n
        }
        // æ‰¾åˆ°äº†è®¡æ•°+1
        n++
        // åˆ‡å‡ºå‰©ä½™å¾…æŸ¥å­—ç¬¦ä¸²
		s = s[i+len(substr):]
	}
}
```
æ€»ç»“ï¼š
1. ä¸»é¢˜å’Œ genSplit å½“ä¸­çš„ for å¾ªç¯å…¶å®æ˜¯ç±»ä¼¼çš„
2. æŒ–ä¸¤ä¸ªå‘ `bytealg.CountString`å’Œ`strings.Index`


---

å‰©ä¸‹çš„å‘ä¸‹æ¬¡å¡«äº†ï¼Œä»Šå¤©å…ˆåˆ°è¿™é‡Œå§ã€‚
